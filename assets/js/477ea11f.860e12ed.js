"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3028],{8667:(e,t,r)=>{r.d(t,{i:()=>o});var n=r(7896),a=r(2784),i=r(8873);const o=e=>{let{storyName:t,iframeProps:r}=e;return a.createElement(i.Z,(0,n.Z)({src:`/storybook/iframe.html?id=${t}&args=&viewMode=story`,frameBorder:0,allowtransparency:"true",style:r.width||r.minWidth||r.maxWidth?{}:{width:"1px",minWidth:"100%"}},r??{}))}},3693:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=r(7896),a=(r(2784),r(876)),i=r(8667);const o={sidebar_position:6},l="Search Functionality",s={unversionedId:"guides/search",id:"guides/search",title:"Search Functionality",description:"Searching for items is natively supported. It looks through all items that are curretly visible in the",source:"@site/docs/guides/search.mdx",sourceDirName:"guides",slug:"/guides/search",permalink:"/docs/guides/search",draft:!1,editUrl:"https://github.com/lukasbach/react-complex-tree/edit/main/packages/docs/docs/guides/search.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Drag and Drop Customizability",permalink:"/docs/guides/drag-and-drop"},next:{title:"Renaming Functionality",permalink:"/docs/guides/renaming"}},c={},p=[{value:"Example",id:"example",level:2},{value:"Configurability",id:"configurability",level:2},{value:"Programmatic interaction",id:"programmatic-interaction",level:2}],d={toc:p};function m(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"search-functionality"},"Search Functionality"),(0,a.kt)("p",null,"Searching for items is natively supported. It looks through all items that are curretly visible in the\ntree, similar to how other tree implementations do it such as the tree view in IntelliJ or VsCode. Search\nis automatically started if the tree is focused and the user starts typing."),(0,a.kt)("p",null,"This also implements the accessibility feature where entering a single character while focusing the tree\nshould move the focus to the first item that matches the character. See the\n",(0,a.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/wai-aria-practices-1.1/examples/treeview/treeview-2/treeview-2a.html#kbd_label"},"W3C spec for keyboard bindings"),"\nfor more details."),(0,a.kt)(i.i,{storyName:"auto-demo-autodemo-component--search-demo",iframeProps:{width:600},mdxType:"StoryEmbed"}),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"All props that can be provided to the tree environment to control search capabilities are documented\nin the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/interfaces/TreeCapabilities"},"TreeCapabilities interface"),".")),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"(TODO) Apparently the search currently does not work properly in the docs pages, where the search input\nis not properly shown. This is an issue with our documentation tooling, not the framework.\nWorking examples are available in the storybook.")),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"Try focusing the tree (i.e. by clicking on it) and start typing to search."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function App() {\n  return (\n    <UncontrolledTreeEnvironment\n      dataProvider={new StaticTreeDataProvider(longTree.items, (item, data) => ({ ...item, data }))}\n      getItemTitle={item => item.data}\n      viewState={{\n        'tree-1': {\n          expandedItems: ['Fruit', 'Meals'],\n        },\n      }}\n    >\n      <Tree treeId=\"tree-1\" rootItem=\"root\" treeLabel=\"Tree Example\" />\n    </UncontrolledTreeEnvironment>\n  );\n}\n")),(0,a.kt)("h2",{id:"configurability"},"Configurability"),(0,a.kt)("p",null,"The prop ",(0,a.kt)("inlineCode",{parentName:"p"},"canSearchByStartingTyping")," manages whether the search can be initiated by just starting to type\nwhile focusing the tree. In the following example, the hotkey ",(0,a.kt)("inlineCode",{parentName:"p"},"F1")," needs to be pressed to start search."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function App() {\n  return (\n    <UncontrolledTreeEnvironment\n      dataProvider={new StaticTreeDataProvider(longTree.items, (item, data) => ({ ...item, data }))}\n      getItemTitle={item => item.data}\n      viewState={{\n        'tree-2': {\n          expandedItems: ['Fruit', 'Meals'],\n        },\n      }}\n      canSearchByStartingTyping={false}\n      keyboardBindings={{\n        startSearch: ['f1'],\n      }}\n    >\n      <Tree treeId=\"tree-2\" rootItem=\"root\" treeLabel=\"Tree Example\" />\n    </UncontrolledTreeEnvironment>\n  );\n}\n")),(0,a.kt)("p",null,"Search can also be disabled completely by setting the prop ",(0,a.kt)("inlineCode",{parentName:"p"},"canSearch")," to false."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function App() {\n  return (\n    <UncontrolledTreeEnvironment\n      dataProvider={new StaticTreeDataProvider(longTree.items, (item, data) => ({ ...item, data }))}\n      getItemTitle={item => item.data}\n      viewState={{\n        'tree-3': {\n          expandedItems: ['Fruit', 'Meals'],\n        },\n      }}\n      canSearch={false}\n    >\n      <Tree treeId=\"tree-3\" rootItem=\"root\" treeLabel=\"Tree Example\" />\n    </UncontrolledTreeEnvironment>\n  );\n}\n")),(0,a.kt)("h2",{id:"programmatic-interaction"},"Programmatic interaction"),(0,a.kt)("p",null,"This feature can programmatically be controlled by pulling a React Ref either from the tree environment\nor the tree itself, and acting on the Ref object. ",(0,a.kt)("a",{parentName:"p",href:"/docs/guides/refs"},"Read the documentation on externally interacting\nwith the tree via Refs")," to find out more."))}m.isMDXComponent=!0},876:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>u});var n=r(2784);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(r),u=a,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||i;return r?n.createElement(h,o(o({ref:t},p),{},{components:r})):n.createElement(h,o({ref:t},p))}));function u(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"}}]);